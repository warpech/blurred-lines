<!DOCTYPE html>
<html>

<head>
    <title>Blurred lines</title>
</head>

<body>
    <table>
        <tr>
            <td>A1</td>
            <td>B1</td>
            <td>C1</td>
            <td>D1</td>
        </tr>
        <tr>
            <td>A2</td>
            <td id="cell1">B2</td>
            <td class="padded">
                <div>C2</div>
            </td>
            <td class="padded" id="cell2">
                <div>D2</div>
            </td>
        </tr>
    </table>


    <svg xmlns="http://www.w3.org/2000/svg">
    </svg>

    <style>
        body {
            font-family: sans-serif;
        }

        table {
            border-spacing: 0;
            margin: 0 0 20px 0;
            border-width: 0;
            table-layout: fixed;
            width: 0;
        }

        td {
            border-style: solid;
            border-color: #ccc;
            border-top-width: 0;
            border-left-width: 0;
            border-right-width: 1px;
            border-bottom-width: 1px;
            height: 3ch;
            width: 5ch;
            empty-cells: show;
            padding: 0 0.2ch 0 0.2ch;
            background-color: #fff;
        }

        td.padded {
            padding: 1px;
        }

        td.padded div {
            background: #bbb;
            display: flex;
            height: 100%;
            align-items: center;
        }

        td:first-child {
            border-left-width: 1px;
        }

        tr:first-child td {
            border-top-width: 1px;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
        }

        path {
            fill: none;
        }

        label {
            display: flex;
            font-size: 11px;
            align-items: center;
            height: 30px;
        }

        label span {
            display: block;
            width: 140px;
        }

        label input {
            display: block;
            width: 100px;
        }
    </style>

    <label><span>Device pixel ratio</span><output id="devicePixelRatio"></output></label>
    <div id="controls"></div>

    <div>
        <button id="reset-preset">Reset</button>
        <button id="handsontable-preset">Handsontable</button>
    </div>

    <script>
        var svg = document.querySelector('svg');
        var cell1 = document.querySelector('#cell1');
        var cell2 = document.querySelector('#cell2');
        var controls = document.querySelector('#controls');
        var state = {};

        function updateState(elem, name, callb, output) {
            var index = parseInt(elem.value, 10);
            state[name] = callb(index);
            output.innerHTML = state[name];
            render();
        }

        function addControl(name, labelText, range, callb) {
            var output = document.createElement('output');

            var input = document.createElement('input');
            input.setAttribute('id', name);
            input.setAttribute('type', 'range');
            input.setAttribute('min', '0');
            input.setAttribute('max', '' + (range - 1));
            input.addEventListener('input', function (ev) { updateState(ev.target, name, callb, output) });
            input.addEventListener('change', function (ev) { updateState(ev.target, name, callb, output) }); // IE9

            var span = document.createElement('span');
            span.innerHTML = labelText;

            var label = document.createElement('label');
            label.appendChild(span);
            label.appendChild(input);
            label.appendChild(output);

            controls.appendChild(label);
        }

        addControl('edgesCount', "Number of edges", 4, (index) => {
            return (index + 1);
        });

        addControl('lineWidthMultiplier', "Line width multiplier", 100, (index) => {
            return (index + 1) / 100;
        });

        var halfPixelCorrectionOptions = ['none', 'simple', 'handsontable'];
        addControl('halfPixelCorrection', "Half pixel correction", halfPixelCorrectionOptions.length, (index) => {
            return halfPixelCorrectionOptions[index];
        });

        var shapeRenderingOptions = ['auto', 'geometricPrecision', 'crispEdges'];
        addControl('shapeRendering', "Shape rendering", shapeRenderingOptions.length, (index) => {
            return shapeRenderingOptions[index];
        });

        var lineChainingOptions = ['no', 'yes'];
        addControl('lineChaining', "Line chaining", lineChainingOptions.length, (index) => {
            return lineChainingOptions[index];
        });

        var pixelGridAlignmentOptions = ['no', 'yes'];
        addControl('pixelGridAlignment', "Align to pixel grid", pixelGridAlignmentOptions.length, (index) => {
            return pixelGridAlignmentOptions[index];
        });

        var dpr = window.devicePixelRatio;
        document.querySelector('#devicePixelRatio').innerHTML = dpr;

        setInterval(function () {
            if (dpr !== window.devicePixelRatio) {
                dpr = window.devicePixelRatio;
                document.querySelector('#devicePixelRatio').innerHTML = dpr;
            }
        }, 250);

        var width = 500;
        var height = 80;
        svg.style.width = width + 'px';
        svg.style.height = height + 'px';
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);

        function drawPathAroundElement(elem, width) {
            var pixelGridAligmnentWidthMultiplier = 1;

            if (state.pixelGridAlignment === 'yes') {
                pixelGridAligmnentWidthMultiplier = normalizeByDevicePixelRatio(pixelGridAligmnentWidthMultiplier);
            }

            var rect = elem.getBoundingClientRect()
            var path = svg.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('stroke', 'blue');
            path.setAttribute('stroke-width', width * state.lineWidthMultiplier * pixelGridAligmnentWidthMultiplier);
            path.setAttribute('stroke-dasharray', 4);
            path.setAttribute('shape-rendering', state.shapeRendering);

            var x1 = rect.left;
            var y1 = rect.top;
            var x2 = x1 + rect.width - (width - 1);
            var y2 = y1 + rect.height - (width - 1);

            var lines = [
                [x1, y1, x2, y1],
                [x2, y1, x2, y2],
                [x2, y2, x1, y2],
                [x1, y2, x1, y1],
            ];

            lines.splice(state.edgesCount);

            if (state.pixelGridAlignment === 'yes') {
                lines = alignToPixelGrid(lines);
            }

            if (state.halfPixelCorrection === 'handsontable') {
                lines = handsontableHalfPixelCorrection(lines, width);
            }
            else if (state.halfPixelCorrection === 'simple') {
                lines = simpleHalfPixelCorrection(lines, width);
            }

            var command = '';
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                if (state.lineChaining === 'yes') {
                    if (i === 0) {
                        command = 'M ' + line[0] + ' ' + line[1] + ' L ' + line[2] + ' ' + line[3] + ' ';
                    }
                    else {
                        if (lines[i - 1][2] === line[0] && lines[i - 1][3] === line[1]) {
                            command += 'L ' + line[2] + ' ' + line[3] + ' ';
                        }
                        else {
                            command += 'M ' + line[0] + ' ' + line[1] + ' L ' + line[2] + ' ' + line[3] + ' ';
                        }
                    }
                }
                else {
                    command += 'M ' + line[0] + ' ' + line[1] + ' L ' + line[2] + ' ' + line[3] + ' ';
                }

            }

            path.setAttribute('d', command);

            svg.appendChild(path);
        }

        function render() {
            empty(this.svg);
            drawPathAroundElement(cell1, 1);
            drawPathAroundElement(cell2, 2);
        }

        function normalizeByDevicePixelRatio(num) {
            return Math.round(num * devicePixelRatio) / devicePixelRatio;
        }

        function alignToPixelGrid(lines) {
            var newLines = new Array(lines.length);

            for (var ii = 0; ii < lines.length; ii++) {
                var x1 = normalizeByDevicePixelRatio(lines[ii][0]);
                var y1 = normalizeByDevicePixelRatio(lines[ii][1]);
                var x2 = normalizeByDevicePixelRatio(lines[ii][2]);
                var y2 = normalizeByDevicePixelRatio(lines[ii][3]);

                newLines[ii] = [x1, y1, x2, y2];
            }

            return newLines;
        }

        function handsontableHalfPixelCorrection(lines, width) {
            var newLines = new Array(lines.length);
            var needSubPixelCorrection = (width % 2 !== 0); // disable antialiasing

            for (var ii = 0; ii < lines.length; ii++) {
                var x1 = lines[ii][0];
                var y1 = lines[ii][1];
                var x2 = lines[ii][2];
                var y2 = lines[ii][3];

                if (needSubPixelCorrection) {
                    var isHorizontal = y1 === y2;

                    if (isHorizontal) {
                        y1 -= 0.5;
                        y2 -= 0.5;
                    } else {
                        x1 -= 0.5;
                        x2 -= 0.5;
                    }
                }

                newLines[ii] = [x1, y1, x2, y2];
            }

            return newLines;
        }

        function simpleHalfPixelCorrection(lines, width) {
            var newLines = new Array(lines.length);
            var needSubPixelCorrection = (width % 2 !== 0); // disable antialiasing

            for (var ii = 0; ii < lines.length; ii++) {
                var x1 = lines[ii][0];
                var y1 = lines[ii][1];
                var x2 = lines[ii][2];
                var y2 = lines[ii][3];

                if (needSubPixelCorrection) {
                    x1 -= 0.5;
                    x2 -= 0.5;
                    y1 -= 0.5;
                    y2 -= 0.5;
                }

                newLines[ii] = [x1, y1, x2, y2];
            }

            return newLines;
        }

        function empty(element) {
            var child;
            while (child = element.lastChild) {
                element.removeChild(child);
            }
        }

        /**
         Presets
         */

        var presetDefault = {
            edgesCount: '4',
            lineWidthMultiplier: '100',
            halfPixelCorrection: halfPixelCorrectionOptions.indexOf('handsontable'),
            shapeRendering: shapeRenderingOptions.indexOf('geometricPrecision'),
            lineChaining: lineChainingOptions.indexOf('yes'),
            pixelGridAlignment: pixelGridAlignmentOptions.indexOf('yes')
        }

        var presetHandsontable = {
            edgesCount: '4',
            lineWidthMultiplier: '100',
            halfPixelCorrection: halfPixelCorrectionOptions.indexOf('handsontable'),
            shapeRendering: shapeRenderingOptions.indexOf('geometricPrecision'),
            lineChaining: lineChainingOptions.indexOf('yes'),
            pixelGridAlignment: pixelGridAlignmentOptions.indexOf('no')
        }

        function applyPreset(preset) {
            var keys = Object.keys(preset);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var elem = document.getElementById(key);
                elem.value = preset[key];
                elem.dispatchEvent(new Event("change"));
            }
        }

        document.querySelector('#reset-preset').addEventListener('click', function () {
            applyPreset(presetDefault);
        });

        document.querySelector('#handsontable-preset').addEventListener('click', function () {
            applyPreset(presetHandsontable);
        });

        applyPreset(presetDefault);
    </script>
</body>

</html>